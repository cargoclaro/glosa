/*
 * Risk analysis helpers for CustomGloss.
 *
 * The first rule implemented: analyse the age of the RFC (tax identifier) found in the Pedimento.
 * Method:
 *   • The RFC encodes a date in YYMMDD format starting at index 3 for moral persons (total 12 chars)
 *     and index 4 for physical persons (total 13 chars).
 *   • We extract that 6-digit date, build a JS Date assuming 19xx or 20xx depending on the year.
 *   • Compare the years difference with the current date.
 *   • Return a RiskLevel: "HIGH" (<2 years), "MEDIUM" (2–5), "LOW" (>5).
 *
 * All functions here are pure and side-effect free so they can be unit-tested easily.
 */

import type { Pedimento } from '../extract-and-structure/schemas';
import fs from 'fs';
import path from 'path';

export type RiskLevel = 'LOW' | 'MEDIUM' | 'HIGH';

export interface RiskAnalysisResult {
  riskName: string;
  level: RiskLevel;
  description: string;
}

// Pre-load aduana ↔ medio transporte catalogue (public JSON)
// File generated by SAT catalogue, kept under public assets so available at runtime.
interface AduanaTransportRecord {
  codigo: string; // e.g. "24 0"
  transportes: number[]; // e.g. [7]
}

let aduanaCatalogue: AduanaTransportRecord[] = [];
try {
  const jsonPath = path.join(process.cwd(), 'public', 'assets', 'jsons', 'relaciones', 'relacion_aduanavsmediodetransporte');
  const raw = fs.readFileSync(jsonPath, 'utf8');
  aduanaCatalogue = JSON.parse(raw) as AduanaTransportRecord[];
} catch (err) {
  // If not found (unit tests, etc.) keep catalogue empty and analyse function will skip
  console.error('Could not load aduana ↔ transporte catalogue', err);
}

/**
 * Extracts the YYMMDD date substring from the RFC.
 * Returns undefined if the RFC does not match the expected pattern.
 */
function extractRfcDate(rfc: string): Date | undefined {
  const cleaned = rfc.trim().toUpperCase();
  // RFC for moral: 3 letters + YYMMDD + 3 alphanum (12 chars)
  // RFC for physical: 4 letters + YYMMDD + 3 alphanum (13 chars)
  const dateStart = cleaned.length === 12 ? 3 : cleaned.length === 13 ? 4 : -1;
  if (dateStart === -1) return undefined;

  const dateStr = cleaned.slice(dateStart, dateStart + 6); // YYMMDD
  if (!/^[0-9]{6}$/.test(dateStr)) return undefined;

  const yy = parseInt(dateStr.slice(0, 2), 10);
  const mm = parseInt(dateStr.slice(2, 4), 10) - 1; // JS months 0-11
  const dd = parseInt(dateStr.slice(4, 6), 10);

  // Assume: if YY > current YY => 1900s else 2000s (simple heuristic)
  const currentYear = new Date().getFullYear() % 100;
  const fullYear = yy > currentYear ? 1900 + yy : 2000 + yy;

  return new Date(fullYear, mm, dd);
}

/**
 * Determine the risk level based on RFC age.
 */
export function getRfcRiskLevel(rfc: string): RiskLevel | undefined {
  const date = extractRfcDate(rfc);
  if (!date) return undefined;

  const now = new Date();
  const ageYears = (now.getTime() - date.getTime()) / (365.25 * 24 * 60 * 60 * 1000);

  if (ageYears < 2) return 'HIGH';
  if (ageYears < 5) return 'MEDIUM';
  return 'LOW';
}

/**
 * Produce a single RiskAnalysisResult for the RFC rule.
 */
export function analyseRfcRisk(pedimento: Pedimento): RiskAnalysisResult | undefined {
  const rfc = pedimento?.encabezadoPrincipalDelPedimento?.datosImportador?.rfc;
  if (!rfc) return undefined;

  const level = getRfcRiskLevel(rfc);
  if (!level) return undefined;

  return {
    riskName: 'Antigüedad del RFC',
    level,
    description:
      level === 'HIGH'
        ? 'El RFC tiene menos de 2 años de antigüedad – riesgo alto.'
        : level === 'MEDIUM'
          ? 'El RFC tiene entre 2 y 5 años de antigüedad – riesgo moderado.'
          : 'El RFC tiene más de 5 años de antigüedad – riesgo bajo.',
  };
}

/**
 * Determine risk when the medio de transporte (entrada/salida) is not allowed for the chosen aduana.
 * Pedimento provides:
 *   - encabezadoPrincipalDelPedimento.aduanaEntradaOSalida  ➜ e.g. "240" (first two digits = aduana number)
 *   - encabezadoPrincipalDelPedimento.mediosTransporte.entradaSalida ➜ string code ("1".."9")
 * Mapping array lists full codes like "24 0" (aduana + seccion). We only need the first two digits.
 */
export function analyseAduanaTransportRisk(pedimento: Pedimento): RiskAnalysisResult | undefined {
  const aduanaRaw = pedimento?.encabezadoPrincipalDelPedimento?.aduanaEntradaOSalida?.trim();
  const medio = pedimento?.encabezadoPrincipalDelPedimento?.mediosTransporte?.entradaSalida?.trim();
  if (!aduanaRaw || !medio) return undefined;

  // First two digits represent aduana number
  const aduanaCode = aduanaRaw.slice(0, 2);
  const medioInt = parseInt(medio, 10);
  if (Number.isNaN(medioInt)) return undefined;

  const allowed = aduanaCatalogue.find((rec) => rec.codigo.startsWith(aduanaCode));
  if (!allowed) return undefined; // no info – skip

  const isAllowed = allowed.transportes.includes(medioInt);
  if (isAllowed) return {
    riskName: 'Aduana vs Medio de Transporte',
    level: 'LOW',
    description: 'El medio de transporte es coherente con la aduana declarada.',
  };

  const opType = pedimento.encabezadoPrincipalDelPedimento.tipoDeOperacion;
  const level: RiskLevel = opType === 'TRA' ? 'MEDIUM' : 'HIGH';

  return {
    riskName: 'Aduana vs Medio de Transporte',
    level,
    description: level === 'MEDIUM'
      ? 'Excepción posible por operación de tránsito (TRA), verificar coherencia.'
      : 'El medio de transporte no está permitido para la aduana declarada – riesgo alto.',
  };
}

/**
 * The main entry point: run all risk rules over a Pedimento.
 */
export function runRiskAnalysis(pedimento: Pedimento): RiskAnalysisResult[] {
  const results: RiskAnalysisResult[] = [];

  const rfcRisk = analyseRfcRisk(pedimento);
  if (rfcRisk) results.push(rfcRisk);

  const aduanaRisk = analyseAduanaTransportRisk(pedimento);
  if (aduanaRisk) results.push(aduanaRisk);

  return results;
} 